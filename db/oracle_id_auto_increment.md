### 什么是 SEQUENCE？

在 Oracle 数据库中，`SEQUENCE` 是一种数据库对象，它可以生成唯一的数字序列，通常用于为表的主键字段生成自增值。序列对象可以保证生成的数值是唯一且按照指定的增量递增（或递减）。与自动生成的字段（如 `IDENTITY`）不同，序列对象是独立的，可以在多个表和场景中复用。

### 创建 SEQUENCE

创建一个序列时，可以指定起始值、增量值以及其他属性。以下是创建一个简单序列的示例：

```sql
CREATE SEQUENCE your_sequence_name
START WITH 1       -- 起始值
INCREMENT BY 1     -- 增量值
NOCACHE            -- 不缓存
NOCYCLE;           -- 不循环
```

### 使用 SEQUENCE

可以通过 `NEXTVAL` 和 `CURRVAL` 伪列来获取序列的下一个值和当前值：

- `NEXTVAL`：生成并返回序列的下一个值。
- `CURRVAL`：返回当前会话中上一次调用 `NEXTVAL` 所生成的值。

#### 获取下一个值

使用 `NEXTVAL` 获取下一个值：

```sql
SELECT your_sequence_name.NEXTVAL FROM dual;
```

### 在插入数据时使用 SEQUENCE

通常，我们会在插入数据时使用 `SEQUENCE` 来生成主键值。以下是一个不使用触发器而直接在插入语句中使用序列的示例：

```sql
INSERT INTO your_table_name (id, content)
VALUES (your_sequence_name.NEXTVAL, 'Some content');
```

### 使用 SEQUENCE 和触发器实现自增主键

在一些场景下，你可能希望使用触发器来自动生成主键值。以下是如何使用 SEQUENCE 和触发器实现自增主键的完整示例：

#### 1. 创建序列

```sql
CREATE SEQUENCE your_sequence_name
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;
```

#### 2. 创建表

```sql
CREATE TABLE your_table_name (
    id NUMBER PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);
```

#### 3. 创建触发器

```sql
CREATE OR REPLACE TRIGGER your_trigger_name
BEFORE INSERT ON your_table_name
FOR EACH ROW
BEGIN
    IF :NEW.id IS NULL THEN
        SELECT your_sequence_name.NEXTVAL INTO :NEW.id FROM dual;
    END IF;
END;
/
```

#### 4. 插入数据

现在，当插入数据时，触发器会自动从序列中获取下一个值并赋值给 `id` 字段：

```sql
INSERT INTO your_table_name (content) VALUES ('First content');
INSERT INTO your_table_name (content) VALUES ('Second content');
```

#### 5. 查询数据

查询表中的数据，查看自动生成的 `id` 值：

```sql
SELECT * FROM your_table_name;
```

### SEQUENCE 的其他选项

- `CACHE n`：缓存 `n` 个序列值以提高性能。缓存的值会在数据库重启时丢失。
- `NOCACHE`：不缓存序列值。
- `CYCLE`：在达到最大值后重新开始从起始值生成。
- `NOCYCLE`：在达到最大值后不重新开始生成值，后续调用会报错。
- `MINVALUE` 和 `MAXVALUE`：设置序列的最小值和最大值。

### 完整示例

以下是一个使用 `SEQUENCE` 和触发器实现自增主键的完整示例：

```sql
-- 创建序列
CREATE SEQUENCE your_sequence_name
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

-- 创建表
CREATE TABLE your_table_name (
    id NUMBER PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);

-- 创建触发器
CREATE OR REPLACE TRIGGER your_trigger_name
BEFORE INSERT ON your_table_name
FOR EACH ROW
BEGIN
    IF :NEW.id IS NULL THEN
        SELECT your_sequence_name.NEXTVAL INTO :NEW.id FROM dual;
    END IF;
END;
/

-- 插入数据
INSERT INTO your_table_name (content) VALUES ('First content');
INSERT INTO your_table_name (content) VALUES ('Second content');

-- 查询数据
SELECT * FROM your_table_name;
```

这个示例展示了如何使用 `SEQUENCE` 和触发器在 Oracle 数据库中实现主键自增的功能。

`GENERATED BY DEFAULT AS IDENTITY` 是 Oracle 数据库在创建表时用于定义自增列的一种方式。这种方式类似于其他数据库系统中的自增（auto-increment）列，例如 MySQL 的 `AUTO_INCREMENT`。

在 Oracle 12c 及更高版本中，引入了 `IDENTITY` 列，可以使用它来自动生成唯一的数值，通常用于主键。以下是如何使用 `GENERATED BY DEFAULT AS IDENTITY` 的详细解释和示例。

### 基本语法

```sql
CREATE TABLE your_table_name (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);
```

在这个示例中，`id` 列将自动生成唯一的数值作为主键。

### 生成策略

`IDENTITY` 列支持两种生成策略：

1. `GENERATED ALWAYS AS IDENTITY`：每次插入时，Oracle 都会自动生成一个唯一的值。如果试图为该列插入一个显式的值，将会导致错误。
2. `GENERATED BY DEFAULT AS IDENTITY`：Oracle 会自动生成一个唯一的值，但允许显式插入值。如果显式插入了一个值，Oracle 将不会生成值。

#### 示例

##### 使用 `GENERATED BY DEFAULT AS IDENTITY`

```sql
CREATE TABLE your_table_name (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);
```

##### 使用 `GENERATED ALWAYS AS IDENTITY`

```sql
CREATE TABLE your_table_name (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);
```

### 自定义生成选项

可以通过添加选项来自定义 `IDENTITY` 列的行为，例如起始值、增量值、缓存等。以下是一个示例：

```sql
CREATE TABLE your_table_name (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1 
        INCREMENT BY 1 
        NOCACHE 
        NOCYCLE
    ) PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);
```

在这个示例中：
- `START WITH 1`：序列从 1 开始。
- `INCREMENT BY 1`：每次递增的步长为 1。
- `NOCACHE`：不在内存中缓存序列值。
- `NOCYCLE`：在达到最大值后不循环。

### 插入数据示例

在插入数据时，Oracle 会自动生成 `id` 列的值：

```sql
INSERT INTO your_table_name (content) VALUES ('First content');
INSERT INTO your_table_name (content) VALUES ('Second content');
```

### 查询数据

查询表中的数据，查看自动生成的 `id` 值：

```sql
SELECT * FROM your_table_name;
```

### 使用显式值插入

如果使用 `GENERATED BY DEFAULT AS IDENTITY`，可以显式插入值：

```sql
INSERT INTO your_table_name (id, content) VALUES (100, 'Explicit ID');
INSERT INTO your_table_name (content) VALUES ('Auto-generated ID');
```

### 完整示例

以下是使用 `GENERATED BY DEFAULT AS IDENTITY` 创建表、插入数据和查询数据的完整示例：

```sql
-- 创建表
CREATE TABLE your_table_name (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1 
        INCREMENT BY 1 
        NOCACHE 
        NOCYCLE
    ) PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);

-- 插入数据
INSERT INTO your_table_name (content) VALUES ('First content');
INSERT INTO your_table_name (content) VALUES ('Second content');

-- 显式插入值
INSERT INTO your_table_name (id, content) VALUES (100, 'Explicit ID');
INSERT INTO your_table_name (content) VALUES ('Auto-generated ID');

-- 查询数据
SELECT * FROM your_table_name;
```

### 总结

使用 `GENERATED BY DEFAULT AS IDENTITY` 可以简化自增主键的实现，避免使用序列和触发器的复杂性。它提供了一种直观且方便的方式来定义自增列，同时支持自定义生成选项以满足不同需求。

在 Oracle 数据库中，每个 `IDENTITY` 列都会有一个独立的隐式序列，即使多个表都使用 `id NUMBER GENERATED BY DEFAULT AS IDENTITY` 作为主键，它们也不会共用同一个隐式序列。每个表的 `IDENTITY` 列都有其独立的序列，确保各表的主键值是独立生成的，不会互相干扰。

### 示例

假设有两个表 `table1` 和 `table2`，它们都使用 `IDENTITY` 列作为主键：

```sql
CREATE TABLE table1 (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);

CREATE TABLE table2 (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    content VARCHAR2(4000) NOT NULL
);
```

每个表都有自己的隐式序列，确保主键值独立生成。

### 插入数据示例

向 `table1` 插入数据：

```sql
INSERT INTO table1 (content) VALUES ('Content for table1');
INSERT INTO table1 (content) VALUES ('Another content for table1');
```

向 `table2` 插入数据：

```sql
INSERT INTO table2 (content) VALUES ('Content for table2');
INSERT INTO table2 (content) VALUES ('Another content for table2');
```

### 查询数据

查询 `table1` 的数据：

```sql
SELECT * FROM table1;
```

查询 `table2` 的数据：

```sql
SELECT * FROM table2;
```

每个表的 `id` 列都独立递增，不会共用同一个序列。

### 验证独立性

为了验证各表的 `IDENTITY` 列是独立的，可以查看每个表的隐式序列信息。虽然 Oracle 不直接提供查看隐式序列的简单方法，但可以通过一些数据字典视图间接验证，例如 `USER_TAB_IDENTITY_COLS` 视图：

```sql
SELECT TABLE_NAME, COLUMN_NAME, IDENTITY_OPTIONS
FROM USER_TAB_IDENTITY_COLS
WHERE TABLE_NAME IN ('TABLE1', 'TABLE2');
```

这个查询会返回 `TABLE1` 和 `TABLE2` 的 `IDENTITY` 列的相关信息，验证它们确实有独立的隐式序列。

### 总结

每个使用 `IDENTITY` 列的表在 Oracle 中都会有一个独立的隐式序列。即使多个表都定义了 `id NUMBER GENERATED BY DEFAULT AS IDENTITY` 作为主键，它们也不会共用同一个隐式序列，确保每个表的主键值是独立生成的，不会互相干扰。